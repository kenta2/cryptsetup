TABFILE="${TABFILE-/etc/crypttab}"

# Logging helpers. Send the argument list to plymouth(1), or fold it
# and print it to the standard error.
cryptsetup_message() {
    local IFS=' '
    if [ "${INITSTATE-}" = "initramfs" ] && [ -x /bin/plymouth ] && plymouth --ping; then
        plymouth message --text="cryptsetup: $*"
    elif [ ${#*} -lt 70 ]; then
        echo "cryptsetup: $*" >&2
    else
        # use busybox's fold(1) and sed(1) at initramfs stage
        echo "cryptsetup: $*" | fold -s | sed '1! s/^/    /' >&2
    fi
    return 0
}

# crypttab_parse_options([$CRYPTTAB_OPTIONS, $export])
#   Parse CRYPTTAB_OPTIONS, a comma-separated option string from the
#   crypttab(5) 4th column, build a suitable CRYPTTAB_OPTION_<option>
#   environment unless $export is "n"
crypttab_parse_options() {
    local options="${1:-$CRYPTTAB_OPTIONS}" export="${2:-y}"
    local IFS=',' x o v
    unset -v CRYPTTAB_OPTION_cipher \
             CRYPTTAB_OPTION_size \
             CRYPTTAB_OPTION_hash \
             CRYPTTAB_OPTION_offset \
             CRYPTTAB_OPTION_skip \
             CRYPTTAB_OPTION_verify \
             CRYPTTAB_OPTION_readonly \
             CRYPTTAB_OPTION_discard \
             CRYPTTAB_OPTION_plain \
             CRYPTTAB_OPTION_luks \
             CRYPTTAB_OPTION_tcrypt \
             CRYPTTAB_OPTION_veracrypt \
             CRYPTTAB_OPTION_swap \
             CRYPTTAB_OPTION_tmp \
             CRYPTTAB_OPTION_check \
             CRYPTTAB_OPTION_checkargs \
             CRYPTTAB_OPTION_tries \
             CRYPTTAB_OPTION_initramfs \
             CRYPTTAB_OPTION_noearly \
             CRYPTTAB_OPTION_noauto \
             CRYPTTAB_OPTION_loud \
             CRYPTTAB_OPTION_quiet \
             CRYPTTAB_OPTION_keyscript \
             CRYPTTAB_OPTION_keyslot \
             CRYPTTAB_OPTION_header \
             CRYPTTAB_OPTION_tcrypthidden
    for x in $options; do
        o="${x%%=*}"
        v="${x#*=}"
        case "$x" in
            cipher=*|hash=*|header=*)
                if [ -z "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: no value for '$o' option, skipping"
                    return 1
                fi
            ;;
            # numeric options >0
            size=*)
                if [ -z "$v" ] || ! printf '%s' "$v" | grep -Exq "[0-9]+" || [ ${v:--1} -le 0 ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            # numeric options >=0
            offset=*|skip=*|tries=*|keyslot=*)
                if [ -z "$v" ] || ! printf '%s' "$v" | grep -Exq "[0-9]+" || [ ${v:--1} -lt 0 ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            ###
            tmp|tmp=*)
                [ "$x" != "$o" ] || v="ext4"
                if [ -z "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: no value for '$o' option, skipping"
                    return 1
                fi
            ;;
            check|check=*)
                if [ "$x" = "$o" ]; then
                    [ -n "${CRYPTDISKS_CHECK-}" ] && v="$CRYPTDISKS_CHECK" || continue
                fi
                if [ -x "/lib/cryptsetup/checks/$v" ] && [ -f "/lib/cryptsetup/checks/$v" ]; then
                    v="/lib/cryptsetup/checks/$v"
                elif [ ! -x "$v" ] || [ ! -f "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            checkargs=*)
            ;;
            keyscript=*)
                if [ "${v#/}" = "$v" ]; then
                    v="/lib/cryptsetup/scripts/$v"
                fi
                if [ ! -x "$v" ] || [ ! -f "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            # and now the flags
            verify|loud|quiet) v="yes";;
            initramfs|noearly|noauto) v="yes";;
            readonly|discard|plain|luks|swap) v="yes";;
            tcrypt|veracrypt|tcrypthidden) v="yes";;
            *)
                cryptsetup_message "WARNING: $CRYPTTAB_NAME: ignoring unknown option '$o'";
                continue
            ;;
        esac
        if [ "$export" != "n" ]; then
            export "CRYPTTAB_OPTION_$o"="$v"
        else
            eval "CRYPTTAB_OPTION_$o"='$v'
        fi
    done
    IFS=' '

    if [ -z "${CRYPTTAB_OPTION_luks+x}" ] && [ -n "${CRYPTTAB_OPTION_header+x}" ]; then
        cryptsetup_message "WARNING: Option 'luks' missing in crypttab for target $CRYPTTAB_NAME." \
                           "Headers are only supported for LUKS devices."
    fi
    if [ -z "${CRYPTTAB_OPTION_luks+x}" ] && [ -z "${CRYPTTAB_OPTION_tcrypt+x}" ]; then
        # the compiled-in default for these are subject to change
        options='cipher size'
        if [ -n "${CRYPTTAB_OPTION_keyscript+x}" ] || [ "$key" = "none" ]; then
            options="$options hash" # --hash is being ignored in plain mode with keyfile specified
        fi
        for o in $options; do
            if eval [ -z "\${CRYPTTAB_OPTION_$o+x}" ]; then
                cryptsetup_message "WARNING: Option '$o' missing in crypttab for plain dm-crypt" \
                    "mapping $CRYPTTAB_NAME. Please read /usr/share/doc/cryptsetup/README.initramfs and" \
                    "add the correct '$o' option to your crypttab(5)."
            fi
        done
    fi
}

# crypttab_copy_keys_to_initramfs($keyscript)
#   Copy keys to the initramfs image for each crypttab(5) entry using
#   the given $keyscript.
#   Return 0 on success, 1 on error.  Exits if the keyscript isn't
#   already installed to the initramfs (by the cryptroot hook file).
crypttab_copy_keys_to_initramfs() {
    local keyscript="/lib/cryptsetup/scripts/$1"
    local crypttab="$DESTDIR/cryptroot/crypttab"
    local CRYPTTAB_NAME CRYPTTAB_SOURCE key options v
    local rv=0

    if [ ! -x "$DESTDIR/$keyscript" ] || [ ! -f "$crypttab" ]; then
        exit 0
    fi

    # Install cryptroot key files into initramfs
    while read CRYPTTAB_NAME CRYPTTAB_SOURCE key options; do
        [ "${CRYPTTAB_NAME#\#}" = "$CRYPTTAB_NAME" ] || continue
        crypttab_parse_options "$options" n || continue
        if [ "${CRYPTTAB_OPTION_keyscript-}" = "$keyscript" ]; then
            if [ -f "$key" ]; then
                copy_file keyfile "$key"
            else
                cryptsetup_message "ERROR: Target $CRYPTTAB_NAME has a non-existing key file $key"
                rv=1
            fi
        fi
    done <"$crypttab"
    return $rv
}

# gen_crypttab_from_kernel_cmdline()
#   Create or replace the initramfs' crypttab(5) with the entries
#   computed from the "cryptopts" kernel boot arguments, if there are
#   any.  (If there are no "cryptopts" kernel boot arguments, then the
#   initramfs' crypttab(5) is preserved.)  This function always touches
#   /cryptroot/crypttab, so other scripts can determine whether it is up
#   to date by comparing its ctime with the uptime.
gen_crypttab_from_kernel_cmdline() {
    mkdir -p /cryptroot # might not exist if there is no crypttab(5) yet
    if ! grep -qE '^(.*\s)?cryptopts=' /proc/cmdline; then
        touch /cryptroot/crypttab
        return 0
    fi

    local IFS=',' cryptopts x
    local target source key options
    tr ' ' '\n' </proc/cmdline | sed -n 's/^cryptopts=//p' | while read cryptopts; do
        # skip empty values (which can be used to disable the initramfs
        # scripts for a particular boot, cf. #873840)
        [ -n "$cryptopts" ] || continue

        unset -v target source key options
        for x in $cryptopts; do
            case "$x" in
                target=*) target="${x#target=}";;
                source=*) source="${x#source=}";;
                key=*) key="${x#key=}";;
                *) options="${options+$options,}$x";;
            esac
        done
        if [ -z "${source:+x}" ]; then
            cryptsetup_message "ERROR: Missing source= value in kernel parameter cryptopts=$cryptopts"
            continue
        else
            printf '%s %s %s %s\n' "${target:-cryptroot}" "$source" \
                                   "${key:-none}" "$options"
        fi
    done >/cryptroot/crypttab
    return 0
}

# normalise_device([--quiet],$device)
#   Print the block device (not symlink) associated with the given
#   (link to a) block $device.  Like for fstab(5), LABEL=<label> or
#   UUID=<uuid> may be given instead of a device name.
#   Return 0 on success, 1 on error.
normalise_device() {
    local dev="$1" quiet='n'
    if [ "$dev" = '--quiet' ] && [ $# -eq 2 ]; then
        quiet='y'
        dev="$2"
    fi

    local input="$dev"
    if [ "${dev#UUID=}" != "$dev" ] && [ -n "${dev#UUID=}" ]; then
        dev="/dev/disk/by-uuid/${dev#UUID=}"
    elif [ "${dev#LABEL=}" != "$dev" ] && [ -n "${dev#LABEL=}" ]; then
        dev="/dev/disk/by-label/$(printf '%s' "${dev#LABEL=}" | sed 's,/,\\x2f,g')"
    fi
    if dev="$(readlink -f -- "$dev")" && [ -n "$dev" ] && [ -b "$dev" ]; then
        printf '%s\n' "$dev"
        return 0
    elif [ "$quiet" = n ]; then
        cryptsetup_message "ERROR: Couldn't normalise device $input"
    fi
    return 1
}

# run_keyscript($keyscriptarg, $tried_count)
#   exec()'ute `$CRYPTTAB_OPTION_keyscript $keyscriptarg`.
#   If $CRYPTTAB_OPTION_keyscript is unset or null and $keyscriptarg is
#   "none" (meaning the passphrase is to be read interactively from the
#   console), use `/lib/cryptsetup/askpass` as keyscript with a suitable
#   prompt message.
#   Since the shell process is replaced with the $CRYPTTAB_OPTION_keyscript
#   program, run_keyscript() must be used on the left-hand side of a
#   pipe, or similar.
run_keyscript() {
    local keyscriptarg="$1" CRYPTTAB_TRIED="$2" keyscript;
    export CRYPTTAB_TRIED

    if [ -n "${CRYPTTAB_OPTION_keyscript+x}" ] && \
            [ "$CRYPTTAB_OPTION_keyscript" != "/lib/cryptsetup/askpass" ]; then
        # 'keyscript' option is present: export its argument as
        # $CRYPTTAB_KEY
        export CRYPTTAB_KEY="$keyscriptarg"
        keyscript="$CRYPTTAB_OPTION_keyscript"
    elif [ "$keyscriptarg" = none ]; then
        # don't export the prompt message as CRYPTTAB_KEY
        keyscript="/lib/cryptsetup/askpass"
        keyscriptarg="Please unlock disk $CRYPTTAB_NAME: "
    fi

    exec "$keyscript" "$keyscriptarg"
}

# get_crypt_type()
#    Return the mapping's type, depending on its
#    $CRYPTTAB_OPTION_<option> values
get_crypt_type() {
    local type="plain" # assume plain dm-crypt device by default
    if [ "${CRYPTTAB_OPTION_tcrypt-}" = "yes" ]; then
        type="tcrypt"
    elif [ "${CRYPTTAB_OPTION_plain-}" = "yes" ]; then
        type="plain"
    elif [ "${CRYPTTAB_OPTION_luks-}" = "yes" ] ||
            /sbin/cryptsetup isLuks -- "${CRYPTTAB_OPTION_header-$CRYPTTAB_SOURCE}"; then
        type="luks"
    fi
    echo "$type"
}

# unlock_mapping($keyfile, $name)
#   Run cryptsetup(8) with suitable options and arguments to unlock
#   $CRYPTTAB_SOURCE and setup dm-crypt managed device-mapper mapping
#   $name
unlock_mapping() {
    local keyfile="$1" name="$2"

    if [ -n "${CRYPTTAB_OPTION_header+x}" ] && [ ! -f "${CRYPTTAB_OPTION_header}" ]; then
        cryptsetup_message "ERROR: $name: LUKS header '${CRYPTTAB_OPTION_header}' missing"
        return 1
    fi

    local type="$(get_crypt_type)"
    if [ "$type" = "luks" ] || [ "$type" = "tcrypt" ]; then
        # ignored for LUKS and TCRYPT devices
        unset -v CRYPTTAB_OPTION_cipher \
                 CRYPTTAB_OPTION_size \
                 CRYPTTAB_OPTION_hash \
                 CRYPTTAB_OPTION_offset \
                 CRYPTTAB_OPTION_skip
    fi
    if [ "$type" != "tcrypt" ]; then
        # ignored for non-TCRYPT devices
        unset -v CRYPTTAB_OPTION_veracrypt CRYPTTAB_OPTION_tcrypthidden
    fi

    if [ "$type" != "luks" ]; then
        # ignored for non-LUKS devices
        unset -v CRYPTTAB_OPTION_keyslot
    fi

    /sbin/cryptsetup -T1 \
        ${CRYPTTAB_OPTION_header:+--header="$CRYPTTAB_OPTION_header"} \
        ${CRYPTTAB_OPTION_cipher:+--cipher="$CRYPTTAB_OPTION_cipher"} \
        ${CRYPTTAB_OPTION_size:+--size="$CRYPTTAB_OPTION_size"} \
        ${CRYPTTAB_OPTION_hash:+--hash="$CRYPTTAB_OPTION_hash"} \
        ${CRYPTTAB_OPTION_offset:+--offset="$CRYPTTAB_OPTION_offset"} \
        ${CRYPTTAB_OPTION_skip:+--skip="$CRYPTTAB_OPTION_skip"} \
        ${CRYPTTAB_OPTION_verify:+--verify-passphrase} \
        ${CRYPTTAB_OPTION_readonly:+--readonly} \
        ${CRYPTTAB_OPTION_discard:+--allow-discards} \
        ${CRYPTTAB_OPTION_veracrypt:+--veracrypt} \
        ${CRYPTTAB_OPTION_keyslot:+--key-slot="$CRYPTTAB_OPTION_keyslot"} \
        ${CRYPTTAB_OPTION_tcrypthidden:+--tcrypt-hidden} \
        --type="$type" --key-file="${keyfile:--}" \
        open -- "$CRYPTTAB_SOURCE" "$name"
}

# check_key($keyfile)
#   Sanity check for keys
check_key() {
    local keyfile="$1"

    if [ ! -f "$keyfile" ] && [ ! -b "$keyfile" ] && [ ! -c "$keyfile" ] ; then
        cryptsetup_message "WARNING: $CRYPTTAB_NAME: keyfile '$keyfile' not found"
        return 0
    fi

    if [ "$keyfile" = "/dev/random" -o "$keyfile" = "/dev/urandom" ]; then
        if [ -n "${CRYPTTAB_OPTION_luks+x}" ] || [ -n "${CRYPTTAB_OPTION_tcrypt+x}" ]; then
            cryptsetup_message "WARNING: $CRYPTTAB_NAME: has random data as key"
            return 1
        else
            return 0
        fi
    fi

    local mode="$(stat -c%a "$keyfile")"
    if [ $(stat -c%u "$keyfile") -ne 0 ] || [ "${mode%00}" = "$mode" ]; then
        cryptsetup_message "WARNING: $CRYPTTAB_NAME: key file $keyfile has" \
            "insecure ownership, see /usr/share/doc/cryptsetup/README.Debian."
    fi
}

# vim: set filetype=sh :
