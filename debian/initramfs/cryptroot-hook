#!/bin/sh

PREREQ=""

prereqs()
{
    echo "$PREREQ"
}

case "$1" in
    prereqs)
        prereqs
        exit 0
        ;;
esac

. /usr/share/initramfs-tools/hook-functions
. /usr/share/cryptsetup/initramfs/functions


# blkid_tag($device, $tag)
#   Print the block device attribute for given $device and $tag.
#   Return 0 on success, 1 on error.
blkid_tag() {
    local device="$1" tag="$2"
    if [ "${device#$tag=}" != "$device" ]; then
        printf '%s\n' "${device#$tag=}"
    elif ! blkid -s "$2" -o value "$device"; then
        cryptsetup_message "ERROR: $device: Couldn't determine $tag"
        return 1
    fi
}

# get_mnt_devices($mountpoint)
#   Print the device (or list of devices - one per line - for  multiple
#   device filesystems) currenty mounted on $mountpoint.
#   Return 0 on success, 1 on error (if $mountpoint is not a mountpoint).
get_mnt_devices() {
    local wantmount="$1" devices= uuid dev
    local device mount type options _

    while read device mountpoint type options _; do
        [ "${device#\#}" = "$device" ] || continue
        if [ "$mountpoint" = "$wantmount" ]; then
            # take the last mountpoint if used several times (shadowed)
            unset -v devices
            if [ "$type" = btrfs ]; then
                # btrfs can span over multiple devices
                if uuid=$(blkid_tag "$device" UUID); then
                    for dev in "/sys/fs/btrfs/$uuid/devices"/*; do
                        dev="/dev/${dev#/sys/fs/btrfs/$uuid/devices/}"
                        devices="${devices:+$devices }$dev"
                    done
                fi
            else
                devices="$device"
            fi
        fi
    done </proc/mounts
    [ -n "${devices:+x}" ] || return 1 # not found
    printf '%s\n' "$devices" | tr ' ' '\n'
}

# sysfs_devdir($name)
#   Print the sysfs(5) hierachy /sys/block/$device associated with
#   device $name.
#   Return 0 on success, 1 on error.
sysfs_devdir() {
    local dev="$(normalise_device "$1")" || return 1
    if [ ! -d "/sys/block/${dev#/dev/}" ]; then
        cryptsetup_message "ERROR: Couldn't find sysfs hierarchy for $1"
        return 1
    fi
    printf '/sys/block/%s\n' "${dev#/dev/}"
}

# get_dmcrypt_slaves(/sys/block/$device)
#   Recursively print the list of underlying dm-crypt devices names for
#   the given $device (typically an md, lv, or dm-crypt device).  Slaves
#   that aren't dm-crypt devices are NOT listed.
get_dmcrypt_slaves() {
    local d="$1" name slave
    [ -d "$d/slaves" ] || return 0
    if [ -d "$d/dm" ]; then
        name="$(cat "$d/dm/name")"
        if dmsetup table "$name" | grep -Eq '^([0-9]+\s+){2}crypt\s'; then
            printf '%s\n' "$name"
        fi
    fi
    for slave in "$d/slaves"/*; do
        if slave="$(readlink -e "$slave")"; then
            get_dmcrypt_slaves "$slave"
        fi
    done
}

# get_crypttab_entry($target)
#   Print the crypttab(5) entry for the given $target.  The entry source
#   is replaced by the corresponding UUID=<uuid> if possible.  If the
#   entry uses the 'decrypt_derived' keyscript, the other crypttab(5)
#   entries it depends on are (recursively) printed before hand.
#   Return 0 on success, 1 on error.
get_crypttab_entry() {
    local name="$1" found='n' slave uuid base
    local target source key options derived
    while read target source key options; do
        [ "${target#\#}" = "$target" ] || continue
        [ "$target" = "$name" ] || continue
        if slave="$(normalise_device "$source")"; then
            if base="$(sysfs_devdir "/dev/mapper/$name")" && \
                    [ ! -e "$base/slaves/${slave#/dev/}" ]; then
                cryptsetup_message "ERROR: Source mismatch: $source != $slave"
            elif uuid="$(blkid_tag "$slave" UUID)"; then
                source="UUID=$uuid"
            fi
        fi
        found='y'
        break
    done </etc/crypttab

    if [ "$found" = n ]; then
        cryptsetup_message "WARNING: No crypttab entry for $name"
        return 1
    fi

    local keyscript
    if ! keyscript="$(crypttab_entry_get_keyscript "$options")"; then
        cryptsetup_message "WARNING: Skipping target $name: invalid keyscript"
        return 1
    fi

    if [ -z "${keyscript:+x}" ] && [ "$key" = '/dev/random' -o "$key" = '/dev/urandom' ]; then
        # XXX: not sure why we have that check at all.  Random swap don't hurt!
        cryptsetup_message "WARNING: Skipping target $name: random key"
        return 1
    fi

    local luks='n'
    if crypttab_options_get_value "$options" 'luks'; then
        luks='y'
    fi

    local header
    if header="$(crypttab_options_get_value "$options" 'header=')"; then
        [ -f "$header" ] || cryptsetup_message "WARNING: Target $name has an invalid header"
        [ "$luks" = y ] || cryptsetup_message "WARNING: Option 'luks' missing in crypttab for target $name." \
                                "Headers are only supported for LUKS devices."
    fi

    local o v
    if [ "$luks" = 'n' ] && ! crypttab_options_get_value "$options" 'tcrypt'; then
        # the compiled-in default for 'cipher' and 'hash' are subject to change
        for o in 'cipher' 'hash' 'size'; do
            if ! v="$(crypttab_options_get_value "$options" "$o=")" || [ -z "$v" ]; then
                cryptsetup_message "WARNING: Option '$o' missing in crypttab for plain dm-crypt" \
                    "mapping $name. Please read /usr/share/doc/cryptsetup/README.initramfs and" \
                    "add the correct '$o' option to your /etc/crypttab."
            fi
        done
    fi

    local newkey
    # if keyscript is set, the "key" is just an argument to the script
    if [ -z "${keyscript:+x}" ] && [ "$key" != "none" ]; then
        case "$key" in
            $KEYFILE_PATTERN)
                mkdir -pm0700 "$DESTDIR/cryptroot/keyfiles"
                newkey="/cryptroot/keyfiles/$target.key"
                copy_file keyfile "$key" "$newkey"
                key="$newkey"
                ;;
            *)
                if [ "$usage" = rootfs ]; then
                    cryptsetup_message "WARNING: Skipping root target $target: uses a key file"
                    return 1
                elif [ "$usage" = resume ]; then
                    cryptsetup_message "WARNING: Resume target $target uses a key file"
                fi
                if newkey=$(readlink -f -- "$key") && [ -f "$newkey" ]; then
                    if [ "$(stat -c %m -- "$newkey" 2>/dev/null)" != '/' ]; then
                        cryptsetup_message "WARNING: Skipping target $target: key file is not on the root FS"
                        return 1
                    fi
                else
                    cryptsetup_message "WARNING: Target $target has a non-existing key file $key"
                    newkey="$key"
                fi
                key="/FIXME-initramfs-rootmnt$newkey"
        esac
        options="$options"
    fi

    [ -z "$keyscript" ] || copy_exec "$keyscript"
    if [ "$keyscript" = '/lib/cryptsetup/scripts/decrypt_derived' ]; then
        # (recursively) list first the device to derive the key from (so
        # the boot scripts unlocks it first)
        get_crypttab_entry "$key"
    fi
    printf '%s %s %s %s\n' "$target" "$source" "$key" "$options"
}

# get_cryptdevs($device, [$device ..])
#   Print the list of crypttab(5) entries for each dm-crypt device
#   holding any of the given $device (which can be an md, a lv, a
#   mapped device, or a regular block device).
get_cryptdevs() {
    local dev base name
    for dev in "$@"; do
        base="$(sysfs_devdir "$dev")" || return 1
        for name in $(get_dmcrypt_slaves "$base"); do
            get_crypttab_entry "$name"
        done
    done
}

# get_resume_device()
#   Return the device(s) used for system suspend/hibernate.
get_resume_device() {
    local dev filename

    # uswsusp
    for filename in /etc/uswsusp.conf /etc/suspend.conf; do
        [ -e "$filename" ] || continue
        dev="$(sed -nr 's/^resume device\s*[:=]\s*//p' "$filename")"
        if [ -n "$dev" ] && [ "$dev" != "<path_to_resume_device_file>" ]; then
            # trim quotes
		    dev=$(printf '%s' "$dev" | sed -re 's/^"(.*)"\s*$/\1/' -e "s/^'(.*)'\s*$/\1/")
            printf '%s\n' "$dev"
        fi
    done

    # regular swsusp
    sed -nr 's,^(.*\s)?resume=(\S+)(\s.*)?$,\2,p' /proc/cmdline

    # initramfs-tools >=0.129
    dev="${RESUME:-auto}"
    if [ "$dev" != none ]; then
        if [ "$dev" = auto ]; then
            # next line from /usr/share/initramfs-tools/hooks/resume
            grep ^/dev/ /proc/swaps | sort -rnk3 | head -n 1 | cut -d " " -f 1
        else
            printf '%s\n' "$dev"
        fi
    fi
}

# generate_initrd_crypttab()
#   Generate the crypttab(5) snippet that is relevant at initramfs
#   stage.  (Devices that aren't required at initramfs stage are
#   ignore.)
generate_initrd_crypttab() {
    local dev usage
    {
        if ! dev="$(get_mnt_devices /)"; then
            cryptsetup_message "WARNING: Couldn't determine root device"
        else
            usage=rootfs get_cryptdevs $dev
        fi

        if dev="$(get_resume_device)"; then
            usage=resume get_cryptdevs $dev
        fi

        if dev="$(get_mnt_devices /usr)"; then
            usage= get_cryptdevs $dev
        fi

        # add crypttab entries with the 'initramfs' option set
        for dev in $(sed -nr 's/^\s*([^#[:blank:]]\S*)\s+\S+\s+\S+\s+(\S+,)?initramfs(,\S+)?$/\1/p' /etc/crypttab); do
            get_crypttab_entry "$dev"
        done

    # remove duplicates (but preserve order)
    } | awk '!seen[$1]++'
}

# list_crypto_modules($name, [$name])
#   Find out which crytpo modules are required for the given list of
#   mapped (crypt) devices names, and append them to the CRYPTO_MODULES
#   variable.
list_crypto_modules() {
    local mod value cipher blockcipher ivhash
    for name in "$@"; do
        [ "${name#\#}" = "$name" ] || continue
        value="$(dmsetup table "$name" | cut -d' ' -f4)"
        cipher="$(printf '%s' "$value" | cut -d':' -f1 | cut -d'-' -f1)"
        if [ -z "$cipher" ]; then
            cryptsetup_message "WARNING: Couldn't determine cipher modules to load for $name"
            continue
        fi
        CRYPTO_MODULES="${CRYPTO_MODULES:+$CRYPTO_MODULES }$cipher"

        blockcipher="$(printf '%s' "$value" | cut -d':' -f1 | cut -d'-' -f1)"
        if [ -n "$blockcipher" ] && [ "$blockcipher" != 'plain' ]; then
            CRYPTO_MODULES="${CRYPTO_MODULES:+$CRYPTO_MODULES }$blockcipher"
        fi

        ivhash="$(printf '%s' "$value" | cut -d':' -s -f2)"
        if [ -n "$ivhash" ] && [ "$ivhash" != 'plain' ]; then
            CRYPTO_MODULES="${CRYPTO_MODULES:+$CRYPTO_MODULES }$ivhash"
        fi
    done
}

# add_modules($glob, $moduledir, [$moduledir ..])
#   Add modules matching under the given $moduledir(s), the name of
#   which mantching $glob.
#   Return 0 if any module was found found, 1 if not.
add_modules() {
    local glob="$1" found=n
    shift
    for mod in $(find -H "$@" -name "$glob.ko" -type f -printf '%f\n'); do
        manual_add_modules "${mod%.ko}"
        found=y
    done
    [ "$found" = y ] && return 0 || return 1
}

# add_crypto_modules($name, [$name ..])
#   Determine kernel module name and add to initramfs.
add_crypto_modules() {
    local mod
    for mod in "$@"; do
        # We have several potential sources of modules (in order of preference):
        #
        #   a) /lib/modules/$VERSION/kernel/arch/$ARCH/crypto/$mod-$specific.ko
        #   b) /lib/modules/$VERSION/kernel/crypto/$mod_generic.ko
        #   c) /lib/modules/$VERSION/kernel/crypto/$mod.ko
        #
        # and (currently ignored):
        #
        #   d) /lib/modules/$VERSION/kernel/drivers/crypto/$specific-$mod.ko
        add_modules "$mod-*" "$MODULESDIR"/kernel/arch/*/crypto \
            || add_modules "${mod}_generic" "$MODULESDIR/kernel/crypto" \
            || add_modules "$mod" "$MODULESDIR/kernel/crypto" \
            || true
    done
}


#######################################################################
# Begin real processing

CRYPTSETUP=''

# Load the hook config
if [ -f "/etc/cryptsetup-initramfs/conf-hook" ]; then
    . /etc/cryptsetup-initramfs/conf-hook
fi

if [ -n "$CRYPTSETUP" ] && [ "$CRYPTSETUP" != 'n' ]; then
    CRYPTSETUP='y'
fi

if [ -n "$KEYFILE_PATTERN" ]; then
    CRYPTSETUP='y'
    case "${UMASK:-$(umask)}" in
        0[0-7]77) ;;
        *) cryptsetup_message "WARNING: Permissive UMASK (${UMASK:-$(umask)})." \
                "Private key material within the initrd might be left unprotected."
        ;;
    esac
fi

CRYPTO_MODULES=
# XXX Maybe post-Buster: deprecate CRYPTSETUP=n (always install the
# cryptsetup integration).  Users that don't want initramfs integration
# can just uninstall the package.
if [ -r /etc/crypttab ] && [ "$CRYPTSETUP" != 'n' ]; then
    mkdir "$DESTDIR/cryptroot"
    generate_initrd_crypttab >"$DESTDIR/cryptroot/crypttab"

    # populate CRYPTO_MODULES
    list_crypto_modules \
        $(sed -rn 's/^\s*([^#[:blank:]]+)\s.*/\1/p' "$DESTDIR/cryptroot/crypttab")
    [ -z "${CRYPTO_MODULES:+x}" ] || CRYPTSETUP='y'
fi

if [ -z "$CRYPTSETUP" ]; then
    cryptsetup_message "WARNING: The initramfs image may not contain cryptsetup binaries nor crypto modules." \
        "If that's on purpose, you may want to uninstall the 'crypsetup-initramfs' package in" \
        "order to disable the cryptsetup initramfs integration and avoid this warning."
elif [ "$CRYPTSETUP" = y ]; then
    # add required components
    manual_add_modules dm_mod
    manual_add_modules dm_crypt

    copy_exec /sbin/cryptsetup
    copy_exec /sbin/dmsetup
    copy_exec /lib/cryptsetup/askpass

    # libargon2 uses pthread_cancel
    LIBC_DIR="$(ldd /sbin/cryptsetup | sed -nr 's#.* => (/lib.*)/libc\.so\.[0-9.-]+ \(0x[[:xdigit:]]+\)$#\1#p')"
    find -L "$LIBC_DIR" -maxdepth 1 -name 'libgcc_s.*' -type f | while read so; do
        copy_exec "$so"
    done

    # We need sed. Either via busybox or as standalone binary.
    if [ "$BUSYBOX" = n ] || [ ! -e "$BUSYBOXDIR/busybox" ]; then
        copy_exec /bin/sed
    fi

    # detect whether the host CPU has AES-NI support
    if grep -Eq '^flags\s*:(.*\s)?aes(\s.*)?$' /proc/cpuinfo; then
        CRYPTO_MODULES="${CRYPTO_MODULES:+$CRYPTO_MODULES }aesni"
    fi

    if [ "$MODULES" = most ]; then
        for d in "$MODULESDIR"/kernel/arch/*/crypto; do
            copy_modules_dir "${d#$MODULESDIR/}"
        done
        copy_modules_dir "kernel/crypto"
    else
        if [ "$MODULES" != "dep" ]; then
            # with large initramfs, we always add a basic subset of modules
            add_crypto_modules aes algif_skcipher cbc chainiv cryptomgr krng sha256 xts
        fi
        add_crypto_modules $(printf '%s' "${CRYPTO_MODULES-}" | tr ' ' '\n' | sort -u)
    fi
    copy_file library /usr/share/cryptsetup/initramfs/functions /lib/cryptsetup/functions
fi
