#!/bin/sh

PREREQ="cryptroot-prepare"

#
# Standard initramfs preamble
#
prereqs()
{
	# Make sure that cryptroot is run last in local-top
	local req
	for req in "${0%/*}"/*; do
		script="${req##*/}"
		if [ "$script" != "${0##*/}" ]; then
			printf '%s\n' "$script"
		fi
	done
}

case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac

# source for log_*_msg() functions, see LP: #272301
. /scripts/functions
. /lib/cryptsetup/functions


# run_keyscript($keyscriptarg, $tried_count)
#   exec()'ute `$CRYPTTAB_OPTION_keyscript $keyscriptarg`.
#   If $CRYPTTAB_OPTION_keyscript is unset or null and $keyscriptarg is
#   "none" (meaning the passphrase is to be read interactively from the
#   console), use `/lib/cryptsetup/askpass` as keyscript with a suitable
#   prompt message.
#   Since the shell process is replaced with the $CRYPTTAB_OPTION_keyscript
#   program, run_keyscript() must be used on the left-hand side of a
#   pipe, or similar.
run_keyscript() {
    local keyscriptarg="$1" CRYPTTAB_TRIED="$2" keyscript;
    export CRYPTTAB_TRIED

    if [ -n "${CRYPTTAB_OPTION_keyscript+x}" ] && \
            [ "$CRYPTTAB_OPTION_keyscript" != "/lib/cryptsetup/askpass" ]; then
        # 'keyscript' option is present: export its argument as
        # $CRYPTTAB_KEY
        export CRYPTTAB_KEY="$keyscriptarg"
        keyscript="$CRYPTTAB_OPTION_keyscript"
    elif [ "$keyscriptarg" = none ]; then
        # don't export the prompt message as CRYPTTAB_KEY
        keyscript="/lib/cryptsetup/askpass"
        keyscriptarg="Please unlock disk $CRYPTTAB_NAME: "
    fi

    exec "$keyscript" "$keyscriptarg"
}

# unlock_mapping([$keyfile])
#   Run cryptsetup(8) with suitable options and arguments to unlock
#   $CRYPTTAB_SOURCE and setup dm-crypt managed device-mapper mapping
#   $CRYPTTAB_NAME
unlock_mapping() {
    local keyfile="$1"

    # Create locking directory before invoking cryptsetup(8) to avoid warnings
    mkdir -pm0700 /run/cryptsetup

    modprobe -q dm_crypt

    if [ -n "${CRYPTTAB_OPTION_header+x}" ] && [ ! -f "${CRYPTTAB_OPTION_header}" ]; then
        cryptsetup_message "ERROR: $CRYPTTAB_NAME: LUKS header '${CRYPTTAB_OPTION_header}' missing"
        return 1
    fi

    local type="plain" # assume plain dm-crypt device by default
    if [ "${CRYPTTAB_OPTION_tcrypt-}" = "yes" ]; then
        type="tcrypt"
    elif [ "${CRYPTTAB_OPTION_plain-}" = "yes" ]; then
        type="plain"
    elif [ "${CRYPTTAB_OPTION_luks-}" = "yes" ] ||
            /sbin/cryptsetup isLuks -- "${CRYPTTAB_OPTION_header-$CRYPTTAB_SOURCE}"; then
        type="luks"
    fi

    if [ "$type" = "luks" ] || [ "$type" = "tcrypt" ]; then
        # ignored for LUKS and TCRYPT devices
        unset -v CRYPTTAB_OPTION_cipher \
                 CRYPTTAB_OPTION_size \
                 CRYPTTAB_OPTION_hash \
                 CRYPTTAB_OPTION_offset \
                 CRYPTTAB_OPTION_skip
    fi
    if [ "$type" != "tcrypt" ]; then
        # ignored for non-TCRYPT devices
        unset -v CRYPTTAB_OPTION_veracrypt CRYPTTAB_OPTION_tcrypthidden
    fi

    if [ "$type" != "luks" ]; then
        # ignored for non-LUKS devices
        unset -v CRYPTTAB_OPTION_keyslot
    fi

    /sbin/cryptsetup -T1 \
        ${CRYPTTAB_OPTION_header:+--header="$CRYPTTAB_OPTION_header"} \
        ${CRYPTTAB_OPTION_cipher:+--cipher="$CRYPTTAB_OPTION_cipher"} \
        ${CRYPTTAB_OPTION_size:+--size="$CRYPTTAB_OPTION_size"} \
        ${CRYPTTAB_OPTION_hash:+--hash="$CRYPTTAB_OPTION_hash"} \
        ${CRYPTTAB_OPTION_offset:+--offset="$CRYPTTAB_OPTION_offset"} \
        ${CRYPTTAB_OPTION_skip:+--skip="$CRYPTTAB_OPTION_skip"} \
        ${CRYPTTAB_OPTION_verify:+--verify-passphrase} \
        ${CRYPTTAB_OPTION_readonly:+--readonly} \
        ${CRYPTTAB_OPTION_discard:+--allow-discards} \
        ${CRYPTTAB_OPTION_veracrypt:+--veracrypt} \
        ${CRYPTTAB_OPTION_keyslot:+--key-slot="$CRYPTTAB_OPTION_keyslot"} \
        ${CRYPTTAB_OPTION_tcrypthidden:+--tcrypt-hidden} \
        --type="$type" --key-file="${keyfile:--}" \
        open -- "$CRYPTTAB_SOURCE" "$CRYPTTAB_NAME"
}

# wait_for_source()
#   Wait for encrypted $CRYPTTAB_SOURCE for up to 180s.  Set
#   $CRYPTTAB_SOURCE to its normalized device name when it shows up;
#   return 1 if timeout.
wait_for_source() {
    local device
    wait_for_udev 10

    if device="$(normalise_device --quiet "$CRYPTTAB_SOURCE")"; then
        # the device is here already, no need to loop
        CRYPTTAB_SOURCE="$device"
        return 0
    fi

    # The lines below has been taken from
    # /usr/share/initramfs-tools/scripts/local's local_device_setup(),
    # as suggested per https://launchpad.net/bugs/164044

    # If the source device hasn't shown up yet, give it a little while
    # to allow for asynchronous device discovery (e.g. USB).

    log_begin_msg "Waiting for encrypted source device $source"

    # Default delay is 180s, cf. initramfs-tools(8)
    local slumber="${ROOTDELAY:-180}"
    while [ $slumber -gt 0 ]; do
        sleep 1

        if [ -x /scripts/local-block/lvm2 ]; then
            # activate any VG that might hold $CRYPTTAB_SOURCE
            /scripts/local-block/lvm2 "$CRYPTTAB_SOURCE"
        fi

        if device="$(normalise_device --quiet "$CRYPTTAB_SOURCE")"; then
            wait_for_udev 10
            log_end_msg 0
            CRYPTTAB_SOURCE="$device"
            return 0
        fi

        slumber=$(( $slumber - 1 ))
    done
    log_end_msg 1 || true
    return 1
}

# setup_mapping($target, $source, $key, $options)
#   Set up a given crypttab(5) mapping
setup_mapping() {
    export CRYPTTAB_NAME="$1" CRYPTTAB_SOURCE="$2" CRYPTTAB_OPTIONS="$4"
    local key="$3"
    crypttab_parse_options || return 1

    # The same target can be specified multiple times
    # e.g. root and resume lvs-on-lvm-on-crypto
    if [ -e "/dev/mapper/$CRYPTTAB_NAME" ]; then
        return 0
    fi

    if ! wait_for_source; then
        # we've given up
        if [ -n "$panic" ]; then
            panic "ALERT! encrypted source device $CRYPTTAB_SOURCE does not exist, can't unlock $CRYPTTAB_NAME."
        else
            # let the user fix matters if they can
            echo "	ALERT! encrypted source device $CRYPTTAB_SOURCE does not exist, can't unlock $CRYPTTAB_NAME."
            echo "	Check cryptopts=source= bootarg: cat /proc/cmdline"
            echo "	or missing modules, devices: cat /proc/modules; ls /dev"
            panic "Dropping to a shell."
        fi
        return 1
    fi

    if [ -z "${CRYPTTAB_OPTION_keyscript+x}" ] && [ "${key#/FIXME-initramfs-rootmnt/}" != "$key" ]; then
        # skip the mapping if the root FS is not mounted yet
        sed -rn 's/^\s*[^#[:blank:]]\S*\s+(\S+)\s.*/\1/p' /proc/mounts | grep -Fxq -- "$rootmnt" || return 1
        # substitute the "/FIXME-initramfs-rootmnt/" prefix by the real root FS mountpoint otherwise
        key="$rootmnt/${key#/FIXME-initramfs-rootmnt/}"
    fi

    if [ -z "${CRYPTTAB_OPTION_keyscript+x}" ] && [ "$key" != "none" ]; then
        if [ ! -f "$key" ]; then
            cryptsetup_message "ERROR: Skipping target $CRYPTTAB_NAME: missing key file $key"
            return 1
        fi
        # try only once if we have a key file
        CRYPTTAB_OPTION_tries=1
    fi

    local count=0 maxtries="${CRYPTTAB_OPTION_tries:-3}" fstype vg
    while [ $maxtries -le 0 ] || [ $count -lt $maxtries ]; do
        count=$(( $count + 1 ))

        if [ -z "${CRYPTTAB_OPTION_keyscript+x}" ] && [ "$key" != "none" ]; then
            # unlock via keyfile
            unlock_mapping "$key"
        else
            # unlock interactively or via keyscript
            run_keyscript "$key" "$count" | unlock_mapping
        fi

        if [ $? -ne 0 ]; then
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: cryptsetup failed, bad password or options?"
            sleep 1
            continue
        elif [ ! -e "/dev/mapper/$CRYPTTAB_NAME" ]; then
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: unknown error setting up device mapping"
            return 1
        fi

        if ! fstype="$(get_fstype "/dev/mapper/$CRYPTTAB_NAME")" || [ "$fstype" = unknown ]; then
            # bad password for plain dm-crypt device?  or mkfs not run yet?
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: unknown fstype, bad password or options?"
            wait_for_udev 10
            /sbin/cryptsetup remove -- "$CRYPTTAB_NAME"
            sleep 1
            continue
        elif [ "$fstype" = lvm2 ]; then
            if [ ! -x /sbin/lvm ]; then
                cryptsetup_message "WARNING: $CRYPTTAB_NAME: lvm is not available"
                return 1
            elif vg="$(lvm pvs --noheadings -o vg_name --config 'log{prefix=""}' "/dev/mapper/$CRYPTTAB_NAME")"; then
                # activate the VG held by the PV we just unlocked
                lvm lvchange -a y --sysinit --ignoreskippedcluster -- "$vg"
            fi
        fi

        cryptsetup_message "$CRYPTTAB_NAME: set up successfully"
        wait_for_udev 10
        return 0
    done

    cryptsetup_message "ERROR: $CRYPTTAB_NAME: maximum number of tries exceeded"
    exit 1
}


#######################################################################
# Begin real processing

# Do we have any kernel boot arguments?
gen_crypttab_from_kernel_cmdline

# Do we have any settings from the /cryptroot/crypttab file?
if [ -s /cryptroot/crypttab ]; then
    while read target source key options <&3; do
        [ "${target#\#}" = "$target" ] || continue
        setup_mapping "$target" "$source" "$key" "$options" 3<&-
    done 3< /cryptroot/crypttab
fi

exit 0
