#!/bin/sh

PREREQ="cryptroot-prepare"

#
# Standard initramfs preamble
#
prereqs()
{
	# Make sure that cryptroot is run last in local-top
	local req
	for req in "${0%/*}"/*; do
		script="${req##*/}"
		if [ "$script" != "${0##*/}" ]; then
			printf '%s\n' "$script"
		fi
	done
}

case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac

# source for log_*_msg() functions, see LP: #272301
. /scripts/functions
. /lib/cryptsetup/functions


# run_keyscript($target, $source, $options, $keyscript, $keyscriptarg, $tried_count)
#   exec()'ute `$keyscript $keyscriptarg` in an environment populated as
#   described by crypttab(5).
#   If $keyscript is null and $keyscriptarg is "none" (meaning the
#   passphrase is to be read interactively from the console), use
#   `/lib/cryptsetup/askpass` as keyscript with a suitable prompt
#   message.
#   Since the shell process is replaced with the $keyscript program,
#   run_keyscript() must be used on the left-hand side of a pipe, or
#   similar.  In which case the CRYPTTAB_OPTION_<option> environment
#   variables don't propagage to the rest of the script.
run_keyscript() {
    local CRYPTTAB_NAME="$1" CRYPTTAB_SOURCE="$2" CRYPTTAB_OPTIONS="$3"
    local keyscript="$4" arg="$5" CRYPTTAB_TRIED="$6"

    export CRYPTTAB_NAME CRYPTTAB_SOURCE CRYPTTAB_OPTIONS CRYPTTAB_TRIED

    if [ -n "$keyscript" ]; then
        # export the keyscript argument as $CRYPTTAB_KEY
        export CRYPTTAB_KEY="$arg"
    elif [ "$arg" = none ]; then
        # don't export CRYPTTAB_KEY, it's just the prompt message
        keyscript="/lib/cryptsetup/askpass"
        arg="Please unlock disk $CRYPTTAB_NAME: "
    fi

    # Populate environment with CRYPTTAB_OPTION_<option>=<value> (or
    # CRYPTTAB_OPTION_<option>="yes" for mere flags)
    local IFS="," o v
    for o in $options; do
        v="${o#*=}"
        [ "$v" != "$o" ] || v="yes"
        o="${o%%=*}"
        # ensure the name is valid (so we can set the variable)
        crypttab_is_valid_option_name "$o" || continue
        export "CRYPTTAB_OPTION_$o"="$v"
    done

    exec "$keyscript" "$arg"
}

# unlock_mapping($target, $source, $key, $options)
#   Run cryptsetup(8) with suitable options and arguments to unlock
#   $source and setup dm-crypt managed device-mapper mapping $target
unlock_mapping() {
    local target="$1" source="$2" key="$3" options="$4"

    # Create locking directory before invoking cryptsetup(8) to avoid warnings
    mkdir -pm0700 /run/cryptsetup

    modprobe -q dm_crypt

    local header=
    if header="$(crypttab_options_get_value "$options" "header=")"; then
        if [ ! -f "$header" ]; then
            cryptsetup_message "ERROR: $target: LUKS header '$header' missing"
            return 1
        fi
    fi

    local type="plain" # assume plain dm-crypt device by default
    if crypttab_options_get_value "$options" "tcrypt"; then
        type="tcrypt"
    elif crypttab_options_get_value "$options" "plain"; then
        type="plain"
    elif crypttab_options_get_value "$options" "luks" ||
            /sbin/cryptsetup isLuks "${header:-$source}"; then
        type="luks"
    fi

    local cipher= size= hash= offset= skip=
    if [ "$type" = "plain" ]; then
        cipher="$(crypttab_options_get_value "$options" "cipher=")"
        size="$(crypttab_options_get_value "$options" "size=")"
        hash="$(crypttab_options_get_value "$options" "hash=")"
        offset="$(crypttab_options_get_value "$options" "offset=")"
        skip="$(crypttab_options_get_value "$options" "skip=")"
    fi

    local verify=
    if crypttab_options_get_value "$options" "verify"; then
        verify="y"
    fi

    local readonly=
    if crypttab_options_get_value "$options" "readonly"; then
        readonly="y"
    fi

    local discard=
    if crypttab_options_get_value "$options" "discard"; then
        discard="y"
    fi

    local veracrypt=
    if [ "$type" = tcrypt ] && crypttab_options_get_value "$options" "veracrypt"; then
        veracrypt="y"
    fi

    # TODO swap, tmp=<tmpfs>, precheck=<precheck>, check=<check>, checkargs=<arguments>
    # TODO initramfs, noearly, noauto, loud, quiet

    local keyslot=
    if [ "$type" = luks ]; then
        keyslot="$(crypttab_options_get_value "$options" "keyslot=")" || true
    fi

    local tcrypthidden=
    if [ "$type" = tcrypt ] && crypttab_options_get_value "$options" "tcrypthidden"; then
        tcrypthidden="y"
    fi

    # populate the environment since our `cryptroot-unlock` searches for
    # a `cryptsetup process` with a matching 'CRYPTTAB_NAME' variable in
    # its environment
    CRYPTTAB_SOURCE="$source" CRYPTTAB_NAME="$target" \
        /sbin/cryptsetup -T1 \
            ${header:+--header="$header"} \
            ${cipher:+--cipher="$cipher"} \
            ${size:+--size="$size"} \
            ${hash:+--hash="$hash"} \
            ${offset:+--offset="$offset"} \
            ${skip:+--skip="$skip"} \
            ${verify:+--verify-passphrase} \
            ${readonly:+--readonly} \
            ${discard:+--allow-discards} \
            ${veracrypt:+--veracrypt} \
            ${keyslot:+--key-slot="$keyslot"} \
            ${tcrypthidden:+--tcrypt-hidden} \
            --type="$type" --key-file="$key" \
            open -- "$source" "$target"
}

# wait_for_source()
#   Wait for encrypted $source for up to 180s.  Set $source to its
#   normalized device name when it shows up; return 1 if timeout.
wait_for_source() {
    local device
    wait_for_udev 10

    if device="$(normalise_device --quiet "$source")"; then
        # the device is here already, no need to loop
        source="$device"
        return 0
    fi

    # The lines below has been taken from
    # /usr/share/initramfs-tools/scripts/local's local_device_setup(),
    # as suggested per https://launchpad.net/bugs/164044

    # If the source device hasn't shown up yet, give it a little while
    # to allow for asynchronous device discovery (e.g. USB).

    log_begin_msg "Waiting for encrypted source device $source"

    # Default delay is 180s, cf. initramfs-tools(8)
    local slumber="${ROOTDELAY:-180}"
    while [ $slumber -gt 0 ]; do
        sleep 1

        if [ -x /scripts/local-block/lvm2 ]; then
            # activate any VG that might hold $source
            /scripts/local-block/lvm2 "$source"
        fi

        if device="$(normalise_device --quiet "$source")"; then
            wait_for_udev 10
            log_end_msg 0
            source="$device"
            return 0
        fi

        slumber=$(( $slumber - 1 ))
    done
    log_end_msg 1 || true
    return 1
}

# setup_mapping($target, $source, $key, $options)
#   Set up a given crypttab(5) mapping
setup_mapping() {
    local target="$1" source="$2" key="$3" options="$4"

    # The same target can be specified multiple times
    # e.g. root and resume lvs-on-lvm-on-crypto
    if [ -e "/dev/mapper/$target" ]; then
        return 0
    fi

    if ! wait_for_source; then
        # We've given up, but we'll let the user fix matters if they can
        echo "	ALERT! encrypted source device $source does not exist, can't unlock $target."
        echo "	Check cryptopts=source= bootarg: cat /proc/cmdline"
        echo "	or missing modules, devices: cat /proc/modules; ls /dev"
        panic "Dropping to a shell."
        return 1
    fi

    local keyscript
    if ! keyscript="$(crypttab_entry_get_keyscript "$options")"; then
        cryptsetup_message "ERROR: Skipping target $target: invalid keyscript"
        return 1
    fi

    if [ -z "${keyscript:+x}" ] && [ "${key#/FIXME-initramfs-rootmnt/}" != "$key" ]; then
        # skip the mapping if the root FS is not mounted yet
        sed -rn 's/^\s*[^#[:blank:]]\S*\s+(\S+)\s.*/\1/p' /proc/mounts | grep -Fxq -- "$rootmnt" || return 1
        # substitute the "/FIXME-initramfs-rootmnt/" prefix by the real root FS mountpoint otherwise
        key="$rootmnt/${key#/FIXME-initramfs-rootmnt/}"
    fi

    local crypttries
    if [ -z "${keyscript:+x}" ] && [ "$key" != "none" ]; then
        if [ ! -f "$key" ]; then
            cryptsetup_message "ERROR: Skipping target $target: missing key file $key"
            return 1
        fi
        # try only once if we have a key file
        crypttries=1
    else
        crypttries="$(crypttab_options_get_value "$options" "tries=")" || true
        case "$crypttries" in
            # substitute default and invalid values
            *[![:digit:].]*|"") crypttries=3;;
        esac
    fi

    local count=0 fstype vg
    while [ $crypttries -le 0 ] || [ $count -lt $crypttries ]; do
        count=$(( $count + 1 ))

        if [ -z "${keyscript:+x}" ] && [ "$key" != "none" ]; then
            # unlock via keyfile
            unlock_mapping "$target" "$source" "$key" "$options"
        else
            # unlock interactively or via keyscript
            run_keyscript "$target" "$source" "$options" "$keyscript" "$key" "$count" | \
                unlock_mapping "$target" "$source" "-" "$options"
        fi

        if [ $? -ne 0 ]; then
            cryptsetup_message "ERROR: $target: cryptsetup failed, bad password or options?"
            continue
        elif [ ! -e "/dev/mapper/$target" ]; then
            cryptsetup_message "ERROR: $target: unknown error setting up device mapping"
            return 1
        fi

        if ! fstype="$(get_fstype "/dev/mapper/$target")" || [ "$fstype" = unknown ]; then
            # bad password for plain dm-crypt device?  or mkfs not run yet?
            cryptsetup_message "ERROR: $target: unknown fstype, bad password or options?"
            wait_for_udev 10
            /sbin/cryptsetup remove -- "$target"
            continue
        elif [ "$fstype" = lvm2 ]; then
            if [ ! -x /sbin/lvm ]; then
                cryptsetup_message "WARNING: $target: lvm is not available"
                return 1
            elif vg="$(lvm pvs --noheadings -o vg_name --config 'log{prefix=""}' "/dev/mapper/$target")"; then
                # active the VG held by the PV we just unlocked
                lvm lvchange -a y --sysinit --ignoreskippedcluster -- "$vg"
            fi
        fi

        cryptsetup_message "$target: set up successfully"
        wait_for_udev 10
        return 0
    done

    cryptsetup_message "ERROR: $target: maximum number of tries exceeded"
    exit 1
}


#######################################################################
# Begin real processing

# Do we have any kernel boot arguments?
gen_crypttab_from_kernel_cmdline

# Do we have any settings from the /cryptroot/crypttab file?
if [ -s /cryptroot/crypttab ]; then
    while read target source key options <&3; do
        [ "${target#\#}" = "$target" ] || continue
        setup_mapping "$target" "$source" "$key" "$options" 3<&-
    done 3< /cryptroot/crypttab
fi

exit 0
