TABFILE="${TABFILE-/etc/crypttab}"

# Logging helpers. Send the argument list to plymouth(1), or fold it
# and print it to the standard error.
cryptsetup_message() {
    local IFS=' '
    if [ "${INITSTATE-}" = "initramfs" ] && [ -x /bin/plymouth ] && plymouth --ping; then
        plymouth message --text="cryptsetup: $*"
    elif [ ${#*} -lt 70 ]; then
        echo "cryptsetup: $*" >&2
    else
        # use busybox's fold(1) and sed(1) at initramfs stage
        echo "cryptsetup: $*" | fold -s | sed '1! s/^/    /' >&2
    fi
    return 0
}

# crypttab_parse_options([$CRYPTTAB_OPTIONS, $export])
#   Parse CRYPTTAB_OPTIONS, a comma-separated option string from the
#   crypttab(5) 4th column, build a suitable CRYPTTAB_OPTION_<option>
#   environment unless $export is "n"
crypttab_parse_options() {
    local options="${1:-$CRYPTTAB_OPTIONS}" export="${2:-y}"
    local IFS=',' x o v
    unset -v CRYPTTAB_OPTION_cipher \
             CRYPTTAB_OPTION_size \
             CRYPTTAB_OPTION_hash \
             CRYPTTAB_OPTION_offset \
             CRYPTTAB_OPTION_skip \
             CRYPTTAB_OPTION_verify \
             CRYPTTAB_OPTION_readonly \
             CRYPTTAB_OPTION_discard \
             CRYPTTAB_OPTION_luks \
             CRYPTTAB_OPTION_tcrypt \
             CRYPTTAB_OPTION_veracrypt \
             CRYPTTAB_OPTION_swap \
             CRYPTTAB_OPTION_tmp \
             CRYPTTAB_OPTION_precheck \
             CRYPTTAB_OPTION_check \
             CRYPTTAB_OPTION_checkargs \
             CRYPTTAB_OPTION_tries \
             CRYPTTAB_OPTION_initramfs \
             CRYPTTAB_OPTION_noearly \
             CRYPTTAB_OPTION_noauto \
             CRYPTTAB_OPTION_loud \
             CRYPTTAB_OPTION_quiet \
             CRYPTTAB_OPTION_keyscript \
             CRYPTTAB_OPTION_keyslot \
             CRYPTTAB_OPTION_header \
             CRYPTTAB_OPTION_tcrypthidden
    for x in $options; do
        o="${x%%=*}"
        v="${x#*=}"
        case "$x" in
            cipher=*|hash=*|header=*)
                if [ -z "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: no value for '$o' option, skipping"
                    return 1
                fi
            ;;
            # numeric options >0
            size=*)
                if [ -z "$v" ] || ! printf '%s' "$v" | grep -Exq "[0-9]+" || [ ${v:--1} -le 0 ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            # numeric options >=0
            offset=*|skip=*|tries=*|keyslot=*)
                if [ -z "$v" ] || ! printf '%s' "$v" | grep -Exq "[0-9]+" || [ ${v:--1} -lt 0 ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            ###
            tmp|tmp=*)
                [ "$x" != "$o" ] || v="ext4"
                if [ -z "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: no value for '$o' option, skipping"
                    return 1
                fi
            ;;
            precheck|precheck=*)
                [ "$x" != "$o" ] || v="$CRYPTDISKS_PRECHECK"
                if [ -x "/lib/cryptsetup/checks/$v" ] && [ -f "/lib/cryptsetup/checks/$v" ]; then
                    v="/lib/cryptsetup/checks/$v"
                elif [ ! -x "$v" ] || [ ! -f "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            check|check=*)
                [ "$x" != "$o" ] || v="$CRYPTDISKS_CHECK"
                if [ -x "/lib/cryptsetup/checks/$v" ] && [ -f "/lib/cryptsetup/checks/$v" ]; then
                    v="/lib/cryptsetup/checks/$v"
                elif [ ! -x "$v" ] || [ ! -f "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            checkargs=*)
            ;;
            keyscript=*)
                if [ "${v#/}" = "$v" ]; then
                    v="/lib/cryptsetup/scripts/$v"
                fi
                if [ ! -x "$v" ] || [ ! -f "$v" ]; then
                    cryptsetup_message "ERROR: $CRYPTTAB_NAME: invalid value for '$o' option, skipping"
                    return 1
                fi
            ;;
            # and now the flags
            verify|loud|quiet) v="yes";;
            initramfs|noearly|noauto) v="yes";;
            readonly|discard|luks|swap) v="yes";;
            tcrypt|veracrypt|tcrypthidden) v="yes";;
            *)
                cryptsetup_message "WARNING: $CRYPTTAB_NAME: ignoring unknown option '$o'";
                continue
            ;;
        esac
        if [ "$export" != "n" ]; then
            export "CRYPTTAB_OPTION_$o"="$v"
        else
            eval "CRYPTTAB_OPTION_$o"='$v'
        fi
    done

    if [ -z "${CRYPTTAB_OPTION_luks+x}" ] && [ -n "${CRYPTTAB_OPTION_header+x}" ]; then
        cryptsetup_message "WARNING: Option 'luks' missing in crypttab for target $CRYPTTAB_NAME." \
                           "Headers are only supported for LUKS devices."
    fi
    if [ -z "${CRYPTTAB_OPTION_luks+x}" ] && [ -z "${CRYPTTAB_OPTION_tcrypt+x}" ]; then
        # the compiled-in default for these are subject to change
        for o in "cipher" "hash" "size"; do
            if eval [ -z "\${$CRYPTTAB_OPTION_$o+x}" ]; then
                cryptsetup_message "WARNING: Option '$o' missing in crypttab for plain dm-crypt" \
                    "mapping $CRYPTTAB_NAME. Please read /usr/share/doc/cryptsetup/README.initramfs and" \
                    "add the correct '$o' option to your crypttab(5)."
            fi
        done
    fi
}

# crypttab_copy_keys_to_initramfs($keyscript)
#   Copy keys to the initramfs image for each crypttab(5) entry using
#   the given $keyscript.
#   Return 0 on success, 1 on error.  Exits if the keyscript isn't
#   already installed to the initramfs (by the cryptroot hook file).
crypttab_copy_keys_to_initramfs() {
    local keyscript="/lib/cryptsetup/scripts/$1"
    local crypttab="$DESTDIR/cryptroot/crypttab"
    local CRYPTTAB_NAME CRYPTTAB_SOURCE key options v
    local rv=0

    if [ ! -x "$DESTDIR/$keyscript" ] || [ ! -f "$crypttab" ]; then
        exit 0
    fi

    # Install cryptroot key files into initramfs
    while read CRYPTTAB_NAME CRYPTTAB_SOURCE key options; do
        [ "${CRYPTTAB_NAME#\#}" = "$CRYPTTAB_NAME" ] || continue
        crypttab_parse_options "$options" n || continue
        if [ "${CRYPTTAB_OPTION_keyscript-}" = "$keyscript" ]; then
            if [ -f "$key" ]; then
                copy_file keyfile "$key"
            else
                cryptsetup_message "ERROR: Target $CRYPTTAB_NAME has a non-existing key file $key"
                rv=1
            fi
        fi
    done <"$crypttab"
    return $rv
}

# gen_crypttab_from_kernel_cmdline()
#   Create or replace the initramfs' crypttab(5) with the entries
#   computed from the "cryptopts" kernel boot arguments, if there are
#   any.  (If there are no "cryptopts" kernel boot arguments, then the
#   initramfs' crypttab(5) is preserved.)  This function always touches
#   /cryptroot/crypttab, so other scripts can determine whether it is up
#   to date by comparing its ctime with the uptime.
gen_crypttab_from_kernel_cmdline() {
    mkdir -p /cryptroot # might not exist if there is no crypttab(5) yet
    if ! grep -qE '^(.*\s)?cryptopts=' /proc/cmdline; then
        touch /cryptroot/crypttab
        return 0
    fi

    local IFS=',' cryptopts x
    local target source key options
    tr ' ' '\n' </proc/cmdline | sed -n 's/^cryptopts=//p' | while read cryptopts; do
        # skip empty values (which can be used to disable the initramfs
        # scripts for a particular boot, cf. #873840)
        [ -n "$cryptopts" ] || continue

        unset -v target source key options
        for x in $cryptopts; do
            case "$x" in
                target=*) target="${x#target=}";;
                source=*) source="${x#source=}";;
                key=*) key="${x#key=}";;
                *) options="${options+$options,}$x";;
            esac
        done
        if [ -z "${source:+x}" ]; then
            cryptsetup_message "ERROR: Missing source= value in kernel parameter cryptopts=$cryptopts"
            continue
        else
            printf '%s %s %s %s\n' "${target:-cryptroot}" "$source" \
                                   "${key:-none}" "$options"
        fi
    done >/cryptroot/crypttab
    return 0
}

# normalise_device([--quiet],$device)
#   Print the block device (not symlink) associated with the given
#   (link to a) block $device.  Like for fstab(5), LABEL=<label> or
#   UUID=<uuid> may be given instead of a device name.
#   Return 0 on success, 1 on error.
normalise_device() {
    local dev="$1" quiet='n'
    if [ "$dev" = '--quiet' ] && [ $# -eq 2 ]; then
        quiet='y'
        dev="$2"
    fi

    local input="$dev"
    if [ "${dev#UUID=}" != "$dev" ] && [ -n "${dev#UUID=}" ]; then
        dev="/dev/disk/by-uuid/${dev#UUID=}"
    elif [ "${dev#LABEL=}" != "$dev" ] && [ -n "${dev#LABEL=}" ]; then
        dev="/dev/disk/by-label/$(printf '%s' "${dev#LABEL=}" | sed 's,/,\\x2f,g')"
    fi
    if dev="$(readlink -f -- "$dev")" && [ -n "$dev" ] && [ -b "$dev" ]; then
        printf '%s\n' "$dev"
        return 0
    elif [ "$quiet" = n ]; then
        cryptsetup_message "ERROR: Couldn't normalise device $input"
    fi
    return 1
}

# vim: set filetype=sh :
