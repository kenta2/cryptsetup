# Logging helpers. Send the argument list to plymouth(1), or fold it
# and print it to the standard error.
cryptsetup_message() {
    if [ -n "${init+x}" ] && [ -x /bin/plymouth ] && plymouth --ping; then
        plymouth message --text="cryptsetup: $*"
    elif [ ${#*} -lt 70 ]; then
        echo "cryptsetup: $*" >&2
    else
        # use busybox's fold(1) and sed(1) at initramfs stage
        echo "cryptsetup: $*" | fold -s | sed '1! s/^/    /' >&2
    fi
    return 0
}

# crypttab_is_valid_option_name($arg)
#   Return 0 if $arg is a valid crypttab(5) option name, and 1
#   otherwise.
crypttab_is_valid_option_name() {
    local arg="$1"
    if printf '%s' "$arg" | grep -Eq "^[_A-Za-z][_0-9A-Za-z]*$"; then
        return 0
    else
        cryptsetup_message "ERROR: Invalid crypttab option name: $arg"
        return 1
    fi
}

# crypttab_options_get_value($options, $arg)
#   Return 1 if $options (taken from the 4th field of the crypttab(5)
#   file entry) contains $arg, and 0 afterwards.  If $arg ends with a
#   '=' character, the option value is printed out.
crypttab_options_get_value() {
    local options="$1" arg="$2"
    if [ "${arg%=}" = "$arg" ]; then
        printf '%s' "$options" | grep -Eq "^(.*,)?$arg(,.*)?$"
    elif printf '%s' "$options" | grep -Eq "^(.*,)?$arg"; then
        printf '%s' "$options" | sed -nr "s;^(.*,)?$arg([^,]*)(,.*)?$;\2;p"
        return 0
    else
        return 1
    fi
}

# crypttab_option_get_keyscript($options)
#   Print the normalised keyscript from $options (taken from the 4th
#   field of the crypttab(5) file entry).
#   Return 0 on success (incl. if $options has no keyscript), 1 on error
#   (invalid keyscript).
crypttab_entry_get_keyscript() {
    local keyscript
    if keyscript="$(crypttab_options_get_value "$options" 'keyscript=')"; then
        [ "${keyscript#/}" != "$keyscript" ] || keyscript="/lib/cryptsetup/scripts/$keyscript"
        if [ ! -f "$keyscript" ] || [ ! -x "$keyscript" ]; then
            return 1
        fi
        printf '%s\n' "$keyscript"
    fi
    return 0
}

# crypttab_copy_keys_to_initramfs($keyscript)
#   Copy keys to the initramfs image for each crypttab(5) entry using
#   the given $keyscript.
#   Return 0 on success, 1 on error.  Exits if the keyscript isn't
#   already installed to the initramfs (by the cryptroot hook file).
crypttab_copy_keys_to_initramfs() {
    local keyscript="/lib/cryptsetup/scripts/$1"
    local crypttab="$DESTDIR/cryptroot/crypttab"
    local target source key options v
    local rv=0

    if [ ! -x "$DESTDIR/$keyscript" ] || [ ! -f "$crypttab" ]; then
        exit 0
    fi

    # Install cryptroot key files into initramfs
    while read target source key options; do
        [ "${target#\#}" = "$target" ] || continue
        if v="$(crypttab_entry_get_keyscript "$options")" &&
                [ "$v" = "$keyscript" ]; then
            if [ -f "$key" ]; then
                copy_file keyfile "$key"
            else
                cryptsetup_message "ERROR: Target $target has a non-existing key file $key"
                rv=1
            fi
        fi
    done <"$crypttab"
    return $rv
}

# gen_crypttab_from_kernel_cmdline()
#   Create or replace the initramfs' crypttab(5) with the entries
#   computed from the "cryptopts" kernel boot arguments, if there are
#   any.  (If there are no "cryptopts" kernel boot arguments, then the
#   initramfs' crypttab(5) is preserved.)
gen_crypttab_from_kernel_cmdline() {
    grep -qE '^(.*\s)?cryptopts=' /proc/cmdline || return 0
    mkdir -p /cryptroot # might not exist if there is no crypttab(5) yet

    local IFS=',' cryptopts x
    local target source key options
    tr ' ' '\n' </proc/cmdline | sed -n 's/^cryptopts=//p' | while read cryptopts; do
        # skip empty values (which can be used to disable the initramfs
        # scripts for a particular boot, cf. #873840)
        [ -n "$cryptopts" ] || continue

        unset -v target source key options
        for x in $cryptopts; do
            case "$x" in
                target=*) target="${x#target=}";;
                source=*) source="${x#source=}";;
                key=*) key="${x#key=}";;
                *) options="${options+$options,}$x";;
            esac
        done
        if [ -z "${source:+x}" ]; then
            cryptsetup_message "ERROR: Missing source= value in kernel parameter cryptopts=$cryptopts"
            continue
        else
            printf '%s %s %s %s\n' "${target:-cryptroot}" "$source" \
                                   "${key:-none}" "$options"
        fi
    done >/cryptroot/crypttab
    return 0
}

# normalise_device([--quiet],$device)
#   Print the block device (not symlink) associated with the given
#   (link to a) block $device.  Like for fstab(5), LABEL=<label> or
#   UUID=<uuid> may be given instead of a device name.
#   Return 0 on success, 1 on error.
normalise_device() {
    local dev="$1" quiet='n'
    if [ "$dev" = '--quiet' ] && [ $# -eq 2 ]; then
        quiet='y'
        dev="$2"
    fi

    local input="$dev"
    if [ "${dev#UUID=}" != "$dev" ] && [ -n "${dev#UUID=}" ]; then
        dev="/dev/disk/by-uuid/${dev#UUID=}"
    elif [ "${dev#LABEL=}" != "$dev" ] && [ -n "${dev#LABEL=}" ]; then
        dev="/dev/disk/by-label/$(printf '%s' "${dev#LABEL=}" | sed 's,/,\\x2f,g')"
    fi
    if dev="$(readlink -f -- "$dev")" && [ -n "$dev" ] && [ -b "$dev" ]; then
        printf '%s\n' "$dev"
        return 0
    elif [ "$quiet" = n ]; then
        cryptsetup_message "ERROR: Couldn't normalise device $input"
    fi
    return 1
}

# vim: set filetype=sh :
