# Logging helpers.  Print the argument list to the standard error.
cryptsetup_warn() {
    echo "cryptsetup: WARNING:" "$@" >&2
}
cryptsetup_fail() {
    echo "cryptsetup: ERROR:" "$@" >&2
}

# crypttab_options_get_value($options, $arg)
#   Return 1 if $options (taken from the 4th field of the crypttab(5)
#   file entry) contains $arg, and 0 afterwards.  If $arg ends with a
#   '=' character, the option value is printed out.
crypttab_options_get_value() {
    local options="$1" arg="$2"
    if [ "${arg%=}" = "$arg" ]; then
        printf '%s' "$options" | grep -Eq "^(.*,)?$arg(,.*)?$"
    elif printf '%s' "$options" | grep -Eq "^(.*,)?$arg"; then
        printf '%s' "$options" | sed -nr "s;^(.*,)?$arg([^,]*)(,.*)?$;\2;p"
        return 0
    else
        return 1
    fi
}

# crypttab_option_get_keyscript($options)
#   Print the normalised keyscript from $options (taken from the 4th
#   field of the crypttab(5) file entry).
#   Return 0 on success (incl. if $options has no keyscript), 1 on error
#   (invalid keyscript).
crypttab_entry_get_keyscript() {
    local keyscript
    if keyscript="$(crypttab_options_get_value "$options" 'keyscript=')"; then
        [ "${keyscript#/}" != "$keyscript" ] || keyscript="/lib/cryptsetup/scripts/$keyscript"
        if [ ! -f "$keyscript" ] || [ ! -x "$keyscript" ]; then
            return 1
        fi
        printf '%s\n' "$keyscript"
    fi
    return 0
}

# crypttab_copy_keys_to_initramfs($keyscript)
#   Copy keys to the initramfs image for each crypttab(5) entry using
#   the given $keyscript.
#   Return 0 on success, 1 on error.  Exits if the keyscript isn't
#   already installed to the initramfs (by the cryptroot hook file).
crypttab_copy_keys_to_initramfs() {
    local keyscript="/lib/cryptsetup/scripts/$1"
    local crypttab="$DESTDIR/cryptroot/crypttab"
    local target source key options v
    local rv=0

    if [ ! -x "$DESTDIR/$keyscript" ] || [ ! -f "$crypttab" ]; then
        exit 0
    fi

    # Install cryptroot key files into initramfs
    while read target source key options; do
        [ "${target#\#}" = "$target" ] || continue
        if v="$(crypttab_entry_get_keyscript "$options")" &&
                [ "$v" = "$keyscript" ]; then
            if [ -f "$key" ]; then
                copy_file keyfile "$key"
            else
                cryptsetup_fail "Target $target has a non-existing key file $key"
                rv=1
            fi
        fi
    done <"$crypttab"
    return $rv
}

# gen_crypttab_from_kernel_cmdline()
#   Create or replace the initramfs' crypttab(5) with the entries
#   computed from the "cryptopts" kernel boot arguments, if there are
#   any.  (If there are no "cryptopts" kernel boot arguments, then the
#   initramfs' crypttab(5) is preserved.)
gen_crypttab_from_kernel_cmdline() {
    grep -qE '^(.*\s)?cryptopts=' /proc/cmdline || return 0
    mkdir -p /cryptroot # might not exist if there is no crypttab(5) yet

    local IFS=',' cryptopts x
    local target source key options
    tr ' ' '\n' </proc/cmdline | sed -n 's/^cryptopts=//p' | while read cryptopts; do
        # skip empty values (which can be used to disable the initramfs
        # scripts for a particular boot, cf. #873840)
        [ -n "$cryptopts" ] || continue

        unset -v target source key options
        for x in $cryptopts; do
            case "$x" in
                target=*) target="${x#target=}";;
                source=*) source="${x#source=}";;
                key=*) key="${x#key=}";;
                *) options="${options+$options,}$x";;
            esac
        done
        if [ -z "${source:+x}" ]; then
            cryptsetup_fail "Missing source= value in kernel parameter cryptopts=$cryptopts"
            continue
        else
            printf '%s %s %s %s\n' "${target:-cryptroot}" "$source" \
                                   "${key:-none}" "$options"
        fi
    done >/cryptroot/crypttab
    return 0
}

# vim: set filetype=sh :
